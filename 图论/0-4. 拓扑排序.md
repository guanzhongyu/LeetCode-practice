### 拓扑排序精讲
概括来说，**给出一个 有向图，把这个有向图转成线性的排序 就叫拓扑排序**。

当然拓扑排序也要检测这个有向图 是否有环，即存在循环依赖的情况，因为这种情况是不能做线性排序的。
所以**拓扑排序也是图论中判断有向无环图的常用方法**。

#### 拓扑排序的思路
拓扑排序指的是一种 解决问题的大体思路， 而具体算法，可能是广搜也可能是深搜。
实现拓扑排序的算法有两种：*卡恩算法（BFS）和DFS*。

**卡恩算法**：
当我们做拓扑排序的时候，应该优先找 入度为 0 的节点，只有入度为0，它才是出发节点。
1. 找到入度为0 的节点，加入结果集
2. 将该节点从图中移除
循环以上两步，直到 所有节点都在图中被移除了。


## [117. 软件构建](https://kamacoder.com/problempage.php?pid=1191) 
### 解题思路
对于拓扑排序，首先要sort将边按权值由小到大排序。

然后输入边`s->t`时，一边记录节点t的入度，一边记录节点s与哪些边相连。

最后BFS使用queue队列，每次加入入度为0的节点，同时将该节点相连的所有节点入度减一，再次判断这些节点入度是否为0，选择性加入队列。

输出答案前，别忘记先**判断是否所有节点都加入result**，这是*判断无环图*的一种方法。


### 代码实现
```C++
#include <iostream>
#include <vector>
#include <queue>
#include <unordered_map>
using namespace std;

int main() {
    int n, m, s, t;
    cin >> n >> m;
    vector<int> inDegree(n, 0);

    unordered_map<int, vector<int>> umap;
    vector<int> result;

    while(m--) {
        cin >> s >> t;
        inDegree[t]++; // t的入度加一
        umap[s].push_back(t); // 记录s指向哪些文件
    }

    queue<int> que;
    for(int i = 0; i < n; i++) {
        if(inDegree[i] == 0) que.push(i);
    }

    while(que.size()) {
        int cur = que.front();
        que.pop();
        result.push_back(cur);
        vector<int> files = umap[cur]; // 获取该文件指向的文件

        if(files.size()) {
            for(int i = 0; i < files.size(); i++) {
                inDegree[files[i]]--; //cur的指向的所有文件入度-1
                if(inDegree[files[i]] == 0) que.push(files[i]);
            }
        }
    }
    if(result.size() == n) {
        for (int i = 0; i < n - 1; i++) cout << result[i] << " ";
        cout << result[n - 1];
    } else cout << -1 << endl;

    return 0;
}
```
