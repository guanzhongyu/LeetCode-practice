### dijkstra朴素版精讲
dijkstra算法：在有权图（*权值非负数*）中求从起点到其他节点的最短路径算法。
需要注意两点：
- dijkstra 算法可以**同时求 起点到所有节点的最短路径**；
- 权值**不能为负数**。

dijkstra 算法 同样是贪心的思路，不断寻找距离 源点最近的没有访问过的节点。
这里我也给出 **dijkstra三部曲**：
1. 第一步，选源点到哪个节点近且该节点未被访问过
2. 第二步，该最近节点被标记访问过
3. 第三步，更新非访问节点到源点的距离（即更新minDist数组）

**minDist数组 用来记录 每一个节点距离源点的最小距离**。

该解法的时间复杂度为 O(n^2)，可以看出时间复杂度 只和 n （节点数量）有关系。

### dijkstra堆优化版精讲
三部曲中第一步（选源点到哪个节点近且该节点未被访问过），这个操作本身需要for循环遍历 minDist 来寻找最近的节点。
同时我们需要 遍历所有 未访问过的节点，所以 我们从 节点角度出发，代码会有两层for循环。
那么当从 边 的角度出发， 在处理 三部曲里的第一步（选源点到哪个节点近且该节点未被访问过）的时候 ，我们可以不用去遍历所有节点了。

而且 直接把 边（带权值）加入到 小顶堆（利用堆来自动排序），那么每次我们从 堆顶里 取出 边 自然就是 距离源点最近的节点所在的边。

C++定义小顶堆，可以用优先级队列实现，代码如下：
```C++
// 小顶堆
class mycomparison {
public:
    bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {
        return lhs.second > rhs.second;
    }
};
// 优先队列中存放 pair<节点编号，源点到该节点的权值> 
priority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pq;
```


## [47. 参加科学大会（第六期模拟笔试）](https://kamacoder.com/problempage.php?pid=1047) 
### 解题思路
dijkstra朴素版算法实现。
和prim算法有相似之处，都需要每次遍历时更新minDist数组。

不同之处在于dijkstra算法更新minDist时，按照：`minDist[v] = minDist[cur] + grid[cur][v];`。
这是因为**prim是求 非访问节点到最小生成树的最小距离，而 dijkstra是求 非访问节点到源点的最小距离**。


### dijkstra朴素版代码实现
```C++
#include <iostream>
#include <vector>
#include <climits>
using namespace std;

int main() {
    int n, m, p1, p2, val;
    cin >> n >> m;

    vector<vector<int>> grid(n+1, vector<int>(n+1, INT_MAX));
    for(int i = 0; i < m; i++) {
        cin >> p1 >> p2 >> val;
        grid[p1][p2] = val;
    }

    int start = 1;
    int end = n;

    vector<int> minDist(n+1, INT_MAX);
    vector<bool> visited(n+1, false);

    minDist[start] = 0; // 起始点到自身的距离为0

    for(int i = 1; i <= n; i++) {
        int minVal = INT_MAX;
        int cur = 1;

        // 选距离源点最近且未访问过的节点
        for(int v = 1; v <= n; v++) {
            if(!visited[v] && minDist[v] < minVal) {
                minVal = minDist[v];
                cur = v;
            }
        }

        visited[cur] = true;

        for(int v = 1; v <= n; v++) {
            if(!visited[v] && grid[cur][v] != INT_MAX && minDist[cur] + grid[cur][v] < minDist[v]) {
                minDist[v] = minDist[cur] + grid[cur][v];
            }
        }
    }

    if(minDist[end] == INT_MAX) cout << -1 << endl;
    else cout << minDist[end] << endl;
}
```


### dijkstra堆优化版代码实现
```C++
#include <iostream>
#include <vector>
#include <list>
#include <queue>
#include <climits>
using namespace std;

// 小顶堆
class mycomparison {
public:
    bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {
        return lhs.second > rhs.second;
    }
};

struct Edge {
    int to;
    int val;

    Edge(int t, int w): to(t), val(w) {}
};

int main() {
    int n, m, p1, p2, val;
    cin >> n >> m;

    vector<list<Edge>> grid(n+1);

    for(int i = 0; i < m; i++) {
        cin >> p1 >> p2 >> val;
        grid[p1].push_back(Edge(p2, val));
    }

    int start = 1;
    int end = n;

    vector<int> minDist(n+1, INT_MAX);
    vector<bool> visited(n+1, false);

    priority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pq;

    // 初始化队列，源点到源点的距离为0，所以初始为0
    pq.push(pair<int, int>(start, 0));

    minDist[start] = 0; // 起始点到自身的距离为0

    while(!pq.empty()) {
        // 1. 第一步，选源点到哪个节点近且该节点未被访问过 （通过优先级队列来实现）
        // <节点， 源点到该节点的距离>
        pair<int, int> cur = pq.top(); pq.pop();

        if(visited[cur.first]) continue;

        // 2. 第二步，该最近节点被标记访问过
        visited[cur.first] = true;

        // 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组）
        for(Edge edge: grid[cur.first]) {
            if(!visited[edge.to] && minDist[cur.first] + edge.val < minDist[edge.to]) {
                minDist[edge.to] = minDist[cur.first] + edge.val;
                pq.push(pair<int, int>(edge.to, minDist[edge.to]));
            }
        }
    }

    if(minDist[end] == INT_MAX) cout << -1 << endl;
    else cout << minDist[end] << endl;
}
```


- 时间复杂度：O(ElogE) E 为边的数量
- 空间复杂度：O(N + E) N 为节点的数量

以上代码中，`while (!pq.empty())` 里套了 `for (Edge edge : grid[cur.first])`。
`for` 里 遍历的是 当前节点 cur 所连接边。