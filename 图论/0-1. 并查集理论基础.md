### 背景
并查集可以解决什么问题呢？
并查集常用来解决连通性问题。
*大白话就是当我们需要判断两个元素是否在同一个集合里的时候，我们就要想到用并查集*。

并查集主要有两个功能：
- 将两个元素添加到一个集合中。
- 判断两个元素在不在同一个集合

### 原理讲解
我们将三个元素A，B，C （分别是数字）放在同一个集合，其实就是将三个元素连通在一起，如何连通呢。
只需要用一个一维数组来表示，即：`father[A] = B，father[B] = C` 这样就表述 A 与 B 与 C连通了（有向连通图）。
```C++
// 将v，u 这条边加入并查集
void join(int u, int v) {
    u = find(u); // 寻找u的根
    v = find(v); // 寻找v的根
    if (u == v) return; // 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回
    father[v] = u;
}
```

这里要讲到寻根思路，只要 A ，B，C 在同一个根下就是同一个集合。
给出A元素，就可以通过 `father[A] = B，father[B] = C`，找到根为 C。
给出B元素，就可以通过 `father[B] = C`，找到根也为为 C，说明 A 和 B 是在同一个集合里。

```C++
// 并查集里寻根的过程
int find(int u) {
    if (u == father[u]) return u; // 如果根就是自己，直接返回
    else return find(father[u]); // 如果根不是自己，就根据数组下标一层一层向下找
}
```

如何表示 C 也在同一个元素里呢？ 我们需要 `father[C] = C`，即C的根也为C，这样就方便表示 A，B，C 都在同一个集合里了。

### 路径压缩
在实现 find 函数的过程中，我们知道，通过递归的方式，不断获取father数组下标对应的数值，最终找到这个集合的根。
搜索过程像是一个多叉树中从叶子到根节点的过程。
如果这棵多叉树高度很深的话，每次find函数 去寻找根的过程就要递归很多次。
除了根节点其他所有节点都挂载根节点下，这样我们在寻根的时候就很快，只需要一步，如果我们想达到这样的效果，就需要 **路径压缩**，将非根节点的所有节点直接指向根节点。 那么在代码层面如何实现呢？

```C++
// 并查集里寻根的过程
int find(int u) {
    if (u == father[u]) return u;
    else return father[u] = find(father[u]); // 路径压缩
}
```

### 时间复杂度
路径压缩后的并查集时间复杂度在O(logn)与O(1)之间，且随着查询或者合并操作的增加，时间复杂度会越来越趋于O(1)。

在第一次查询的时候，相当于是n叉树上从叶子节点到根节点的查询过程，时间复杂度是logn，但路径压缩后，后面的查询操作都是O(1)，而 join 函数 和 isSame函数 里涉及的查询操作也是一样的过程。