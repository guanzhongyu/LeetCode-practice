### prim算法精讲
最小生成树是所有节点的最小连通子图，即：以最小的成本（边的权值）将图中所有节点链接到一起。
图中有n个节点，那么一定可以用n-1条边将所有节点连接到一起。
那么如何选择这n-1条边就是最小生成树算法的任务所在。

prim算法是从节点的角度采用贪心的策略每次寻找距离最小生成树最近的节点并加入到最小生成树中。
prim算法核心就是三步：
1. 第一步，选距离生成树最近节点
2. 第二步，最近节点加入生成树
3. 第三步，更新非生成树节点到生成树的距离（即更新minDist数组）

**minDist数组用来记录每一个节点距离最小生成树的最近距离**。


## [53. 寻宝（第七期模拟笔试）](https://kamacoder.com/problempage.php?pid=1053) 
### 解题思路
最小生成树prim算法


### 代码实现
```C++
#include <iostream>
#include <vector>
#include <climits>
using namespace std;

int main() {
    int v, e;
    cin >> v >> e;
    int x, y, k;
    vector<vector<int>> grid(v+1, vector<int>(v+1, 10001));
    while(e--) {
        cin >> x >> y >> k;
        grid[x][y] = k;
        grid[y][x] = k;
    }

    vector<int> minDist(v+1, 10001);
    vector<bool> isInTree(v+1, false);

    // 我们只需要循环 n-1次，建立 n - 1条边，就可以把n个节点的图连在一起
    for(int i = 1; i < v; i++) {
        // 1、prim三部曲，第一步：选距离生成树最近节点
        int cur = -1;
        int minVal = INT_MAX;
        for(int j = 1; j <= v; j++) {  // 找到minDist中最小的节点
            if(!isInTree[j] && minDist[j] < minVal) {
                minVal = minDist[j];
                cur = j;
            }
        }

        // 2、prim三部曲，第二步：最近节点（cur）加入生成树
        isInTree[cur] = true;
        
        // 检查minDist是否比原来小了
        for(int j = 1; j <= v; j++) {
            if(!isInTree[j] && grid[cur][j] < minDist[j]) {
                minDist[j] = grid[cur][j];
            }
        }
    }

    int result = 0;
    for(int i = 2; i <= v; i++) {
        result += minDist[i];
    }
    cout << result << endl;
}

```
